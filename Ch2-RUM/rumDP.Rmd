---
title: "Does shark depredation influence recreation fishers site choice?"
author: "Nicole Hamre"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    df_print: paged
    toc: yes
    toc_float: yes
    theme: cosmo
    number_section: true
---

```{r setglobal, include = FALSE}
knitr::opts_chunk$set(fig.align = "center",
                      fig.width = 7, 
                      fig.height = 5, 
                      dev = "png",
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

```{r packages, include = FALSE}
# install.packages("tidyverse")
# install.packages("devtools")
# install.packages("remotes")
# install.packages("sp")
# install.packages("raster")
# install.packages("ggplot2")
# install.packages("leaflet")
# install.packages("rgeos")
# install.packages("rgdal")
# install.packages("sf") # select no
# install.packages('dismo', dependencies=TRUE) 
# install.packages('gbm', dependencies=TRUE) 
# devtools::install_github("JBjouffray/ggBRT") 

library(tidyverse)
library(devtools)
library(remotes)
library(sp)
library(raster)
library(ggplot2)
library(leaflet)
library(rgeos)
library(rgdal)
library(sf)
library(dismo)
library(gbm)
library(ggBRT)

```

```{r dir, echo = FALSE}
w.dir <- "/Users/23088313/Documents/git_repos/Analysis-Hamre-Agent-lobster"
d.dir <- paste(w.dir, "Ch2-RUM/rumIgnore", sep='/')
s.dir <- paste(w.dir, "spIgnore/shp", sep='/')
r.dir <- paste(w.dir, "spIgnore/raster", sep='/')
rumPlots <- paste(w.dir, "Ch2-RUM/rumPlots", sep='/')
```

```{r readData, echo = FALSE}
Ning <- read.csv(paste(d.dir, "Ning_v2.csv", sep = "/"))
```

Hyp 1: Shark depredation will influence site choice for residents with familiar knowledge of the area.  
Hyp 2:Shark depredation will not influence site choice for visitor, which will typically go for sites with a lower travel cost, therefore in areas with higher concentartion of boat and in areas of depredation hotspots. 

```{r DataPrep, include = FALSE}
exdat <- Ning %>%
  dplyr::select(ID, PersonID, TripNum, SiteNum, Date, Month, numYear, facYear, Time, TripJulianDay, FieldTrip, Side, Site, GridID, SiteType, SurveyLat, SurveyLong,
                Screen18,PrevInter, Agreement, Resident, ResnBoatDaysYr, nBoatDays, nTimesLast12m, nTimes19, Covid, UseLat, UseLong,
                ActivityType, exRecall, FishingType, BaitLure, exStart, exStop, exMedianTime, exDecMedianTime, DecFishingHr, FishingHr,
                StillThere, MaxHook, KeptUndam, RelUndam, CaughtUndam, nHooked, DP, nDP, perDP, nUndamHr, nDPHr,
                nHookedHr, DPrateHr, Species, exWhyLeave, exnTimes12m, exYrs, FishLife, FishOcc, nTimesFished, jDaysBoatFished, jDaysBoatFishedCat, jBRAvid, LunarPhase, DistNearestBRkm, DistNearestInfra,
                Depth, Habitat, Postcode, YrBorn, Sex, Party, Accom, BoatID, BoatType, BoatLength, Comments)

exdat <- exdat %>%
  filter(ActivityType =="Extractive")
```

Response rate for full extractive data set is...
```{r ResponseRate, echo = FALSE}
a <- exdat %>%
  distinct(PersonID, .keep_all = TRUE) 

nApproached <- nrow(a)
nNE <- length(which(a$Agreement == "NE"))
nPartcipants <- length(which(a$Agreement == "Yes"))

ResponseRate = (nPartcipants/(nApproached - nNE))*100

ResponseRate
```

# Creating depredation data set {.tabset}
The dataset has been filter to only include responses, and to reflect fishing types applicable to depredation - demersal, casting and trolling, as can be seen in table below. 


```{r filter_yes, include = FALSE}
exdat <- exdat %>%
  filter(Agreement == "Yes")
```

```{r fishingtype_DP, echo = FALSE}
exdat %>%
  group_by(FishingType) %>%
  summarise(TotalDP = sum(nDP, na.rm = TRUE))
```

```{r filter_fishingtype, echo = FALSE}
dpdat <- exdat %>%
  filter(FishingType == "Casting"|FishingType == "Demersal"|FishingType == "Trolling")
```

```{r filter_sitetype, include = FALSE, echo = FALSE}
# This will need added when site type has be double checked. 
# dpdat %>%
#   group_by(SiteType) %>%
#   summarise(TotalDP = sum(nDP, na.rm = TRUE))
```

```{r fivekm, include = FALSE, echo = FALSE}
# exdat1 <- exdat %>%
#  mutate(fivekm = lengths(st_is_within_distance(spNing, spNing, dist = 5000))) 
# 
#   mutate(fivekm_day = lengths(st_is_within_distance(spNing, spNing, dist = 5000)))
```

Having been filtered by fishing type, the histogram below show the number of uses in data set associated with each type of fishing.  


```{r FTyp_dp, echo = FALSE}
FTyp_dp <- dpdat %>% 
  group_by(FishingType) %>%   
  mutate(count_name_occurr = n()) %>%
  filter(!is.na(FishingType), FishingType != "") %>%
  ggplot(
  aes(x=reorder(FishingType,-count_name_occurr))) + #reorder(col to reorder, by what var)
  geom_bar(stat='count', fill = "mediumaquamarine") +
  labs(x = "Fishing Type (n = 3)", y = "Frequency (n = 622)") +
  geom_text(stat='count', aes(label=..count..), vjust = -0.5, size = 2.5)

FTyp_dp

ggsave(paste(rumPlots, "FTyp_dp.png", sep='/'), width = 8, height = 4)
```

# Totals {.tabset}
## Overall

```{r toverall, echo = FALSE}
 dpdat %>% 
  summarise(TotalHooked = sum(nHooked, na.rm = TRUE),
                     TotalDP = sum(nDP, na.rm = TRUE),
                     TotalperDP = (TotalDP/TotalHooked)*100)

nDP_hist <- ggplot(dpdat) +
  aes(x = nDP) +
  geom_histogram(fill = "mediumaquamarine") +
  labs(x = "Number of fish depredated (n= 994)")

nDP_hist

ggsave(paste(rumPlots, "nDP_hist.png", sep='/'), width = 8, height = 4)

nHooked_hist <- ggplot(dpdat) +
  aes(x = nHooked) +
  geom_histogram(fill = "mediumaquamarine") +
  labs(x = "Number of fish hooked (n = 6548)")

nHooked_hist

ggsave(paste(rumPlots, "nHooked_hist.png", sep='/'), width = 8, height = 4)
```

## Faceted by side of cape
```{r toverall_fside, echo = FALSE}
dpdat %>% 
  group_by(Side) %>%
  summarise(TotalHooked = sum(nHooked, na.rm = TRUE),
                     TotalDP = sum(nDP, na.rm = TRUE),
                     TotalperDP = (TotalDP/TotalHooked)*100) 
```

## Faceted by Year

```{r toverall_fyear, echo = FALSE}
dpdat %>% 
  group_by(facYear) %>%
  summarise(TotalHooked = sum(nHooked, na.rm = TRUE),
                     TotalDP = sum(nDP, na.rm = TRUE),
                     TotalperDP = (TotalDP/TotalHooked)*100) 

```

## Facetted by side and year
```{r toverall_fyearside, echo = FALSE}
dpdat %>% 
  group_by(facYear, Side) %>%
  summarise(TotalHooked = sum(nHooked, na.rm = TRUE),
                     TotalDP = sum(nDP, na.rm = TRUE),
                     TotalperDP = (TotalDP/TotalHooked)*100) 
```

# Averages {.tabset}
## Overall
```{r avoverall, echo = FALSE}
dpdat %>% 
  summarise(AvHooked = mean(nHooked, na.rm = TRUE),
            AvDP = mean(nDP, na.rm = TRUE),
            AvperDP = (AvDP/AvHooked)*100) 

```
## Faceted by side of cape
```{r avoverall_fside, echo = FALSE}
dpdat %>% 
  group_by(Side) %>%
  summarise(AvHooked = mean(nHooked, na.rm = TRUE),
            AvDP = mean(nDP, na.rm = TRUE),
            AvperDP = (AvDP/AvHooked)*100) 
```
## Faceted by Year
```{r avoverall_fyear, echo = FALSE}
dpdat %>% 
  group_by(facYear) %>%
  summarise(AvHooked = mean(nHooked, na.rm = TRUE),
            AvDP = mean(nDP, na.rm = TRUE),
            AvperDP = (AvDP/AvHooked)*100) 

dpdat %>%
  group_by(facYear) %>%
  summarise(avDP = mean(nDP)) %>%
ggplot( 
  aes(y = avDP, x = facYear)) +
  geom_col(fill = "mediumaquamarine") +
  labs(x = "Average number of depredated at each site", y = "Year")

ggsave(paste(rumPlots, "avDP.png", sep='/'), width = 8, height = 4)

dpdat %>%
  group_by(facYear) %>%
  summarise(avCR = mean(CaughtUndam)) %>%
ggplot( 
  aes(y = avCR, x = facYear)) +
  geom_col(fill = "mediumaquamarine") +
  labs(x = "Average catch rate per site", y = "Year")

ggsave(paste(rumPlots, "avCR.png", sep='/'), width = 8, height = 4)
```
## Faceted by side of cape and year
```{r avoverall_fyearside, echo = FALSE}
 dpdat %>% 
  group_by(facYear, Side) %>%
  summarise(TotalHooked = sum(nHooked, na.rm = TRUE),
                     TotalDP = sum(nDP, na.rm = TRUE),
                     TotalperDP = (TotalDP/TotalHooked)*100) 
```

# Depredation BRT {.tabset}
Boosted regression trees

The BRT approach differs fundamentally from traditional regression methods that produce a single ‘best’ model, instead using the technique of boosting to combine large numbers of relatively simple tree models adaptively, to optimize predictive performance. 

Learning rate (lr) determines the contribution of each tree to the growing model. Decreasing (slowing) lr increases the number of trees required, and in general a smaller lr (and larger nt) are preferable, conditional on the number of obser- vations and time available for computation.

Tree complexity (tc) controls whether interactions are fitted. A tc of 1 (single decision stump; two terminal nodes) fits an additive model, a tc of two fits a model with up to two-way interactions, and so on. For a given lr, fitting more complex trees leads to fewer trees being required for minimum error. So, as tc is increased, lr must be decreased if sufficient trees are to be fitted.

As a general guide, lr needs to be decreased as tc increases, usually inversely: doubling tc should be matched with halving lr to give approximately the same nt. 

Number of trees (nt), the lr and tc determine the number of trees (nt) required for optimal prediction.

Bag fraction (bf), controls stochasticity that specifies the proportion of data to be selected at each step. The default bag fraction is 0·5, meaning that, at each iteration, 50% of the data are drawn at random, without replacement, from the full training set. In our experience, stochasticity improves model performance, and fractions in the range 0·5–0·75 have given best results for presence–absence responses. 

Step size, is the number of trees added at each step. 

Before making a BRT we need to find the optimal number of trees using gbm step. Model being run on gbm step:

Number of fish depredated ~ Site number , Year , Month , Side , Resident , Resident boat avidity , local avidity , Lat , Long , Fishing type , Bait or Lure , Decimal fishing hours , Max Hook , years fishing , Boat ramp avidity , Boat length , Boat type , lunar phase

The output below is has the optimal parameters of:

lr = 0.1

tc = 3

bf = 0.9

nt = 1000

step size = 50

This was determined through selecting model with smallest residual devience when parameters were run through the following loop `grid<-expand.grid(lr=c(0.1, 0.05, 0.01), tc=c(2, 3, 5), bf=c(0.5, 0.75, 0.9))`
```{r loop grid, include=FALSE}
## making a grid for loop
res.dev<-c() ## make a res.dev variable to store in grid
grid<-expand.grid(lr=c(0.1, 0.05, 0.01), tc=c(2, 3, 5), bf=c(0.5, 0.75, 0.9)) ## make grid of lr, tc and bag.fraction that gbm.step will run through 
grid$res.dev<-NA ## add red.dev to grid
```

```{r prepping variables, include = FALSE}
# All varibale need to be numeric or a factor
dpdat <- dpdat %>%
  dplyr::mutate(Month = as.factor(Month),
                Side = as.factor(Side),
                FishingType = as.factor(FishingType),
                BaitLure = as.factor(BaitLure),
                BoatType = as.factor(BoatType),
                LunarPhase = as.factor(LunarPhase),
                Habitat = as.factor(Habitat))
## make ex median time decimal and add

```

BRT Model
nDP ~ TripNum + SiteNum + numYear + Month + Side+ Resident + ResnBoatDaysYr+ nTimesLast12m + exDecMedianTime + nHooked + Depth + Habitat + DistNearestBRkm + DistNearestInfra + UseLat + UseLong + FishingType+ BaitLure + DecFishingHr + MaxHook + exYrs + jBRAvid + BoatLength + LunarPhase

TripJulianDay as random factor

```{r dp.step loop, include = FALSE}
for(i in 1:nrow(grid)) {
  dp.step<-dismo::gbm.step(data=dpdat,
                           gbm.x=c("TripNum", "SiteNum", "numYear", "Month", "Side", "Resident",
                                   "ResnBoatDaysYr", "nTimesLast12m","exDecMedianTime", "nHooked",
                                   "Depth", "Habitat","DistNearestBRkm", "DistNearestInfra", "UseLat",
                                   "UseLong","FishingType", "BaitLure", "DecFishingHr","MaxHook",
                                   "exYrs", "jBRAvid", "BoatLength", "LunarPhase"), ## explanatory
                           gbm.y=c(46),## response - number of fish depredated
                           #offset=c("nHooked"), ## adds offset 
                           ##fold.vector=dat$folds, 
                           lr=grid[i,"lr"], ## ref to grid 
                           tc=grid[i,"tc"], ## ref to grid 
                           step.size=50,
                           family="poisson", ## distribution family
                           bag.fraction=grid[i,"bf"])
  grid[i, "res.dev"] <-dp.step$self.statistics$mean.resid} ### store res.dev in grid `

```

```{r grid, echo = FALSE}
grid
```

```{r dp.step, echo = FALSE}
  dp.step<-dismo::gbm.step(data=dpdat,
                           gbm.x=c("TripNum", "SiteNum", "numYear", "Month", "Side", "Resident",
                                   "ResnBoatDaysYr", "nTimesLast12m","exDecMedianTime",
                                   "Depth", "Habitat","DistNearestBRkm", "DistNearestInfra", "UseLat",
                                   "UseLong","FishingType", "BaitLure", "DecFishingHr","MaxHook",
                                   "exYrs", "jBRAvid", "BoatLength", "LunarPhase"), ## explanatory
                           gbm.y=c(46),## response - number of fish depredated
                           offset=c(44), ## adds offset 
                           ##fold.vector=dat$folds, 
                           lr=0.1, ## ref to grid 
                           tc=3, ## ref to grid 
                           step.size=50,
                           family="poisson", ## distribution family
                           bag.fraction=0.9)

```

```{r output of dp.step}

vars<-expand.grid(vars=c(1:24))

ggPerformance(dp.step)
ggInfluence(dp.step, show.signif = TRUE) ## better influence summary - used gbm.step 
# ggsave(paste(rumPlots, "dpInfluence.step.png", sep='/'), width = 8, height = 4)

# for(i in 1:nrow(vars)) {
# ggPD(dp.step,rug = T, smooth = T, predictor = grid[i, "vars"])
# }## plots PDP for fitted functions  no CI for every variable in a matrix

ggPD(dp.step, rug = T, smooth = T, n.plots = 8)
     
# ggsave(paste(rumPlots, "dpPD.step.png", sep='/'), width = 8, height = 4)
ggPDfit(dp.step, n.plot = 8, smooth = T, se = T) ## plots PDPs for fitted value no CI for evey variable in a matrix 

ggInteract_list(dp.step, index = F) ## shows table of interactions-only showing baittype?

```

```{r}
dp.step_prerun<- plot.gbm.4list(dp.step)

dp.step_boot <- gbm.bootstrap.functions(dp.step, list.predictors=dp.step_prerun, n.reps=100)

dp.step_PDboot<-ggPD_boot(dp.step, list.4.preds=dp.step_prerun, 
                booted.preds=dp.step_boot$function.preds, type.ci="ribbon", rug=T, n.plot = 8)
```



```{r BRT}
dp.BRT <- gbm::gbm(
  formula = nDP ~ TripNum + SiteNum+ numYear+ Month+ Side+ Resident+
                                   ResnBoatDaysYr+ nTimesLast12m+exDecMedianTime+
                                   Depth+ Habitat+DistNearestBRkm+ DistNearestInfra+ UseLat+
                                   UseLong+FishingType+ BaitLure+ DecFishingHr+MaxHook+
                                   exYrs+ jBRAvid+ BoatLength+ LunarPhase, offset(nHooked),
  distribution = "poisson",
  data = dpdat,
  n.trees = 1250,
  shrinkage = 0.1, # lr
  bag.fraction = 0.9,
  interaction.depth = 3) # txc

summary(dp.BRT, las = 1, cex.names = 0.5)

pretty.gbm.tree(dp.BRT, i.tree=1) 


plot.gbm(dp.BRT, i.var=c(1)) 
plot.gbm(dp.BRT, i.var=c(2)) 
plot.gbm(dp.BRT, i.var=c(3)) 
plot.gbm(dp.BRT, i.var=c(4)) 
plot.gbm(dp.BRT, i.var=c(5)) 
plot.gbm(dp.BRT, i.var=c(6)) 
plot.gbm(dp.BRT, i.var=c(7)) 
plot.gbm(dp.BRT, i.var=c(8)) 
plot.gbm(dp.BRT, i.var=c(9)) 
plot.gbm(dp.BRT, i.var=c(10)) 
plot.gbm(dp.BRT, i.var=c(11)) 
plot.gbm(dp.BRT, i.var=c(12))
plot.gbm(dp.BRT, i.var=c(13)) 
plot.gbm(dp.BRT, i.var=c(14)) 
plot.gbm(dp.BRT, i.var=c(15)) 
plot.gbm(dp.BRT, i.var=c(16)) 
plot.gbm(dp.BRT, i.var=c(17)) 
plot.gbm(dp.BRT, i.var=c(18)) 
plot.gbm(dp.BRT, i.var=c(19)) 
plot.gbm(dp.BRT, i.var=c(10)) 
plot.gbm(dp.BRT, i.var=c(21)) 
plot.gbm(dp.BRT, i.var=c(22)) 
plot.gbm(dp.BRT, i.var=c(23)) 


# par(mfrow=c(1,1)) 
# plot.gbm(dp.BRT, i.var=c(1:24)) ## doesnt like vector 
# gbm.plot.fits(dp.BRT)
# 
# 
# i.var <- c(1:23)
# ylab <- c("TripNum", "SiteNum", "numYear", "Month", "Side", "Resident",
#                                    "ResnBoatDaysYr", "nTimesLast12m","exDecMedianTime",
#                                    "Depth", "Habitat","DistNearestBRkm", "DistNearestInfra", "UseLat",
#                                    "UseLong","FishingType", "BaitLure", "DecFishingHr","MaxHook",
#                                    "exYrs", "jBRAvid", "BoatLength", "LunarPhase")
# 
# grid2 <- cbind(i.var, ylab)
# 
# for(i in nrow(grid2)) {
#   plot.gbm(dp.BRT, i.var=grid2[i, "i.var"] ,ylab=grid2[i, "ylab"]) 
# }

```


```{r}
spDPdat <- st_read(paste(s.dir, "spNing.shp", sep = '/')) %>%
  st_transform(crs = 3112)

spNing_Lam <- as.ppp(spNing_Lam)
spNingkm_Lam <- rescale(spNing_Lam, 1000, "km")

spNingkm_Lam$KernalDensity <- density(spNingkm_Lam, sigma = 5) # Using the default bandwidth
kdens <- plot(spNingkm_Lam$KernalDensity, main=NULL, las=1)
contour(spNingkm_Lam$KernalDensity, add=TRUE)
```


